#!/usr/bin/env python3

import gi
gi.require_version("Gtk", "3.0")
from gi.repository import Gtk, Gdk, GdkPixbuf, GLib
import json
import subprocess
from pathlib import Path
import os

CONFIG_DIR = Path.home() / ".config" / "toast"
SETTINGS_FILE = CONFIG_DIR / "settings.json"

current_provider = None


# ===========================
# SETTINGS
# ===========================

def load_settings():
    CONFIG_DIR.mkdir(parents=True, exist_ok=True)
    if not SETTINGS_FILE.exists():
        save_settings({"theme": "light"})
        return {"theme": "light"}

    try:
        with open(SETTINGS_FILE, "r") as f:
            return json.load(f)
    except:
        return {"theme": "light"}


def save_settings(settings):
    CONFIG_DIR.mkdir(parents=True, exist_ok=True)
    with open(SETTINGS_FILE, "w") as f:
        json.dump(settings, f, indent=2)


# ===========================
# THEME
# ===========================

def apply_theme(window, theme_name):
    global current_provider

    css_path = (
        Path(__file__).resolve().parent.parent
        / "data" / "css" / f"{theme_name}.css"
    )

    if not css_path.exists():
        return

    screen = Gdk.Screen.get_default()

    if current_provider is not None:
        Gtk.StyleContext.remove_provider_for_screen(screen, current_provider)

    provider = Gtk.CssProvider()
    provider.load_from_path(str(css_path))

    Gtk.StyleContext.add_provider_for_screen(
        screen, provider, Gtk.STYLE_PROVIDER_PRIORITY_APPLICATION
    )

    current_provider = provider


# ===========================
# AUTOSTART HANDLING
# ===========================

def scan_autostart():
    entries = []

    user_dir = Path.home() / ".config" / "autostart"
    system_dir = Path("/etc/xdg/autostart")

    if user_dir.exists():
        for f in user_dir.glob("*.desktop"):
            entries.append((f, "user"))

    if system_dir.exists():
        for f in system_dir.glob("*.desktop"):
            entries.append((f, "system"))

    return entries


def parse_desktop_file(filepath):
    name = filepath.stem
    comment = ""
    icon = ""
    enabled = True

    try:
        with open(filepath, "r") as f:
            for line in f:
                if line.startswith("Name="):
                    name = line.split("=", 1)[1].strip()
                elif line.startswith("Comment="):
                    comment = line.split("=", 1)[1].strip()
                elif line.startswith("Icon="):
                    icon = line.split("=", 1)[1].strip()
                elif line.startswith("Hidden="):
                    enabled = not ("true" in line.lower())
    except:
        pass

    return name, comment, icon, enabled


def set_enabled(filepath, enabled):
    try:
        lines = []
        found = False
        with open(filepath, "r") as f:
            for line in f:
                if line.startswith("Hidden="):
                    found = True
                    line = "Hidden=false\n" if enabled else "Hidden=true\n"
                lines.append(line)

        if not found:
            lines.append("Hidden=false\n" if enabled else "Hidden=true\n")

        with open(filepath, "w") as f:
            f.writelines(lines)
    except:
        pass


def delete_autostart(filepath):
    try:
        Path(filepath).unlink(missing_ok=True)
    except:
        pass


# ===========================
# CREATE ENTRY WINDOW
# ===========================

class NewEntryWindow(Gtk.Window):
    def __init__(self, parent):
        super().__init__(title="New Autostart Entry")
        self.parent = parent

        self.set_default_size(350, 300)
        self.set_modal(True)
        self.set_transient_for(parent)

        box = Gtk.Box(orientation=Gtk.Orientation.VERTICAL, spacing=10)
        box.set_margin_top(15)
        box.set_margin_bottom(15)
        box.set_margin_left(20)
        box.set_margin_right(20)
        self.add(box)

        # Name
        lbl_name = Gtk.Label(label="Name:")
        lbl_name.set_xalign(0)
        self.entry_name = Gtk.Entry()

        # Command
        lbl_cmd = Gtk.Label(label="Command:")
        lbl_cmd.set_xalign(0)
        self.entry_cmd = Gtk.Entry()

        # Comment
        lbl_comment = Gtk.Label(label="Comment:")
        lbl_comment.set_xalign(0)
        self.entry_comment = Gtk.Entry()

        # Icon
        lbl_icon = Gtk.Label(label="Icon (name or path):")
        lbl_icon.set_xalign(0)
        self.entry_icon = Gtk.Entry()

        box.pack_start(lbl_name, False, False, 0)
        box.pack_start(self.entry_name, False, False, 0)

        box.pack_start(lbl_cmd, False, False, 0)
        box.pack_start(self.entry_cmd, False, False, 0)

        box.pack_start(lbl_comment, False, False, 0)
        box.pack_start(self.entry_comment, False, False, 0)

        box.pack_start(lbl_icon, False, False, 0)
        box.pack_start(self.entry_icon, False, False, 0)

        # Buttons
        btn_box = Gtk.Box(spacing=10)
        btn_cancel = Gtk.Button(label="Cancel")
        btn_create = Gtk.Button(label="Create")

        btn_cancel.connect("clicked", lambda x: self.destroy())
        btn_create.connect("clicked", self.on_create)

        btn_box.pack_end(btn_create, False, False, 0)
        btn_box.pack_end(btn_cancel, False, False, 0)

        box.pack_end(btn_box, False, False, 0)

    def on_create(self, button):
        name = self.entry_name.get_text().strip()
        cmd = self.entry_cmd.get_text().strip()
        comment = self.entry_comment.get_text().strip()
        icon = self.entry_icon.get_text().strip()

        if not name or not cmd:
            self.destroy()
            return

        autostart_dir = Path.home() / ".config" / "autostart"
        autostart_dir.mkdir(parents=True, exist_ok=True)

        filename = autostart_dir / f"{name.replace(' ', '_')}.desktop"

        text = [
            "[Desktop Entry]\n",
            "Type=Application\n",
            f"Name={name}\n",
            f"Exec={cmd}\n",
        ]

        if comment:
            text.append(f"Comment={comment}\n")
        if icon:
            text.append(f"Icon={icon}\n")

        text.append("Hidden=false\n")
        text.append("X-GNOME-Autostart-enabled=true\n")

        with open(filename, "w") as f:
            f.writelines(text)

        self.parent.refresh_autostart()
        self.destroy()

class EditEntryWindow(Gtk.Window):
    def __init__(self, parent, filepath, name, cmd, comment, icon):
        super().__init__(title="Edit Autostart Entry")
        self.parent = parent
        self.filepath = filepath

        self.set_default_size(350, 300)
        self.set_modal(True)
        self.set_transient_for(parent)

        box = Gtk.Box(orientation=Gtk.Orientation.VERTICAL, spacing=10)
        box.set_margin_top(15)
        box.set_margin_bottom(15)
        box.set_margin_left(20)
        box.set_margin_right(20)
        self.add(box)

        # Name
        lbl_name = Gtk.Label(label="Name:")
        lbl_name.set_xalign(0)
        self.entry_name = Gtk.Entry()
        self.entry_name.set_text(name)

        # Command
        lbl_cmd = Gtk.Label(label="Command:")
        lbl_cmd.set_xalign(0)
        self.entry_cmd = Gtk.Entry()
        self.entry_cmd.set_text(cmd)

        # Comment
        lbl_comment = Gtk.Label(label="Comment:")
        lbl_comment.set_xalign(0)
        self.entry_comment = Gtk.Entry()
        self.entry_comment.set_text(comment)

        # Icon
        lbl_icon = Gtk.Label(label="Icon (name or path):")
        lbl_icon.set_xalign(0)
        self.entry_icon = Gtk.Entry()
        self.entry_icon.set_text(icon)

        for widget in [
            lbl_name, self.entry_name,
            lbl_cmd, self.entry_cmd,
            lbl_comment, self.entry_comment,
            lbl_icon, self.entry_icon,
        ]:
            box.pack_start(widget, False, False, 0)

        # Buttons
        btn_box = Gtk.Box(spacing=10)
        btn_cancel = Gtk.Button(label="Cancel")
        btn_save = Gtk.Button(label="Save")

        btn_cancel.connect("clicked", lambda x: self.destroy())
        btn_save.connect("clicked", self.on_save)

        btn_box.pack_end(btn_save, False, False, 0)
        btn_box.pack_end(btn_cancel, False, False, 0)

        box.pack_end(btn_box, False, False, 0)

    def on_save(self, button):
        name = self.entry_name.get_text().strip()
        cmd = self.entry_cmd.get_text().strip()
        comment = self.entry_comment.get_text().strip()
        icon = self.entry_icon.get_text().strip()

        if not name or not cmd:
            self.destroy()
            return

        lines = [
            "[Desktop Entry]\n",
            "Type=Application\n",
            f"Name={name}\n",
            f"Exec={cmd}\n",
        ]

        if comment:
            lines.append(f"Comment={comment}\n")
        if icon:
            lines.append(f"Icon={icon}\n")

        lines.append("Hidden=false\n")
        lines.append("X-GNOME-Autostart-enabled=true\n")

        with open(self.filepath, "w") as f:
            f.writelines(lines)

        self.parent.refresh_autostart()
        self.destroy()



# ===========================
# SERVICES
# ===========================

def scan_services():
    try:
        output = subprocess.check_output(
            ["systemctl", "--user", "list-unit-files", "--type=service", "--no-pager"],
            stderr=subprocess.DEVNULL
        ).decode()
    except:
        return []

    services = []

    for line in output.splitlines():
        if not line.endswith(".service"):
            continue

        parts = line.split()
        if len(parts) < 2:
            continue

        name = parts[0]
        enabled = (parts[1] == "enabled")

        services.append((name, enabled, True))

    return services


def set_service_enabled(name, enabled):
    try:
        if enabled:
            subprocess.run(["systemctl", "--user", "enable", name],
                           stdout=subprocess.DEVNULL, stderr=subprocess.DEVNULL)
        else:
            subprocess.run(["systemctl", "--user", "disable", name],
                           stdout=subprocess.DEVNULL, stderr=subprocess.DEVNULL)
    except:
        pass


# ===========================
# FILTERING
# ===========================

def toast_filter_list(data, text, columns):
    text = text.lower()
    results = []

    for row in data:
        for col in columns:
            if text in str(row[col]).lower():
                results.append(row)
                break

    return results


# ===========================
# MAIN WINDOW
# ===========================

class ToastWindow(Gtk.Window):
    def __init__(self):
        super().__init__(title="Toast")
        self.set_default_size(950, 600)

        self.settings = load_settings()

        # ===== HEADER BAR =====
        hb = Gtk.HeaderBar()
        hb.set_show_close_button(True)
        hb.props.title = "Toast"
        self.set_titlebar(hb)

        # Hamburger Menu
        self.menu_button = Gtk.MenuButton()
        icon = Gtk.Image.new_from_icon_name("open-menu-symbolic", Gtk.IconSize.BUTTON)
        self.menu_button.add(icon)

        menu = Gtk.Menu()

        item_new = Gtk.MenuItem(label="New Autostart Entry")
        item_delete = Gtk.MenuItem(label="Delete Selected")
        item_edit = Gtk.MenuItem(label="Edit Selected")

        item_new.connect("activate", self.on_new_entry)
        item_delete.connect("activate", self.on_delete_selected)
        item_edit.connect("activate", self.on_edit_selected)

        menu.append(item_new)
        menu.append(item_delete)
        menu.append(item_edit)
        menu.show_all()

        self.menu_button.set_popup(menu)
        hb.pack_start(self.menu_button)

        # Search
        self.search_entry = Gtk.SearchEntry()
        self.search_entry.set_placeholder_text("Searchâ€¦")
        self.search_entry.connect("search-changed", self.on_search)
        hb.pack_start(self.search_entry)

        # Theme toggle
        btn_theme = Gtk.Button(label="Theme")
        btn_theme.connect("clicked", self.on_toggle_theme)
        hb.pack_end(btn_theme)

        # Refresh
        btn_refresh = Gtk.Button(label="Refresh")
        btn_refresh.connect("clicked", self.on_refresh)
        hb.pack_end(btn_refresh)

        # ===== PANED SPLIT =====
        paned = Gtk.Paned.new(Gtk.Orientation.HORIZONTAL)
        self.add(paned)

        # ===== AUTOSTART PANEL =====
        left_box = Gtk.Box(orientation=Gtk.Orientation.VERTICAL)
        left_label = Gtk.Label(label="Autostart Entries")
        left_label.set_margin_top(10)
        left_box.pack_start(left_label, False, False, 0)

        # ListStore columns:
        # 0 = Name
        # 1 = Enabled
        # 2 = Filepath
        # 3 = Source
        # 4 = IconName
        # 5 = Comment

        self.autostart_list = Gtk.ListStore(str, bool, str, str, str, str)

        self.autostart_view = Gtk.TreeView(model=self.autostart_list)

        # Enabled toggle
        renderer_toggle = Gtk.CellRendererToggle()
        renderer_toggle.connect("toggled", self.on_toggle_autostart)
        col_toggle = Gtk.TreeViewColumn("On", renderer_toggle, active=1)
        self.autostart_view.append_column(col_toggle)

        # Icon
        renderer_icon = Gtk.CellRendererPixbuf()
        col_icon = Gtk.TreeViewColumn("", renderer_icon, icon_name=4)
        self.autostart_view.append_column(col_icon)

        # Name
        col_name = Gtk.TreeViewColumn("App", Gtk.CellRendererText(), text=0)
        col_name.set_expand(True)
        self.autostart_view.append_column(col_name)

        # Tooltip per row
        self.autostart_view.set_tooltip_column(5)

        scroll_left = Gtk.ScrolledWindow()
        scroll_left.add(self.autostart_view)

        left_box.pack_start(scroll_left, True, True, 0)
        paned.add1(left_box)

        # ===== SERVICES PANEL =====
        right_box = Gtk.Box(orientation=Gtk.Orientation.VERTICAL)
        right_label = Gtk.Label(label="User Services")
        right_label.set_margin_top(10)
        right_box.pack_start(right_label, False, False, 0)

        self.services_list = Gtk.ListStore(str, bool, bool)

        self.services_view = Gtk.TreeView(model=self.services_list)

        renderer_toggle2 = Gtk.CellRendererToggle()
        renderer_toggle2.connect("toggled", self.on_toggle_service)
        col_service_toggle = Gtk.TreeViewColumn("On", renderer_toggle2, active=1)
        self.services_view.append_column(col_service_toggle)

        col_service_name = Gtk.TreeViewColumn("Service", Gtk.CellRendererText(), text=0)
        col_service_name.set_expand(True)
        self.services_view.append_column(col_service_name)

        scroll_right = Gtk.ScrolledWindow()
        scroll_right.add(self.services_view)

        right_box.pack_start(scroll_right, True, True, 0)
        paned.add2(right_box)

        # Load all
        self.refresh_autostart()
        self.refresh_services()

        apply_theme(self, self.settings["theme"])

    # ===========================
    # DATA LOADERS
    # ===========================

    def refresh_autostart(self):
        self.autostart_list.clear()

        entries = scan_autostart()
        self._autostart_original = []

        if not entries:
            self.autostart_list.append(["(empty)", False, "", "", "", ""])
            return

        for filepath, source in entries:
            name, comment, icon, enabled = parse_desktop_file(filepath)

            if not icon:
                icon = "application-x-executable"

            row = [name, enabled, str(filepath), source, icon, comment or "No description available"]
            self.autostart_list.append(row)
            self._autostart_original.append(row)

    def refresh_services(self):
        self.services_list.clear()

        entries = scan_services()
        self._services_original = []

        if not entries:
            self.services_list.append(["(empty)", False, False])
            return

        for name, enabled, writable in entries:
            row = [name, enabled, writable]
            self.services_list.append(row)
            self._services_original.append(row)

     # ===========================
    # EVENTS
    # ===========================

    def on_refresh(self, button):
        self.search_entry.set_text("")
        self.refresh_autostart()
        self.refresh_services()

    def on_toggle_theme(self, button):
        new_theme = "dark" if self.settings["theme"] == "light" else "light"
        self.settings["theme"] = new_theme
        save_settings(self.settings)
        apply_theme(self, new_theme)

    def on_new_entry(self, menuitem):
        win = NewEntryWindow(self)
        win.show_all()

    def on_delete_selected(self, menuitem):
        if self.search_entry.get_text().strip() != "":
            return

        selection = self.autostart_view.get_selection()
        model, treeiter = selection.get_selected()
        if not treeiter:
            return

        name, enabled, filepath, source, icon, comment = model[treeiter]

        if source == "system":
            return
        if name == "(empty)":
            return

        delete_autostart(filepath)
        self.refresh_autostart()

    def on_edit_selected(self, menuitem):
        if self.search_entry.get_text().strip() != "":
            return

        selection = self.autostart_view.get_selection()
        model, treeiter = selection.get_selected()
        if not treeiter:
            return

        name, enabled, filepath, source, icon, comment = model[treeiter]

        if source == "system":
            return
        if name == "(empty)":
            return

        cmd = ""
        try:
            with open(filepath, "r") as f:
                for line in f:
                    if line.startswith("Exec="):
                        cmd = line.split("=", 1)[1].strip()
        except:
            pass

        win = EditEntryWindow(self, filepath, name, cmd, comment, icon)
        win.show_all()

    def on_toggle_autostart(self, widget, path):
        iter = self.autostart_list.get_iter(path)
        name, enabled, filepath, source, icon, comment = self.autostart_list[iter]

        if source == "system":
            return

        new_val = not enabled
        self.autostart_list[iter][1] = new_val
        set_enabled(filepath, new_val)

    def on_toggle_service(self, widget, path):
        iter = self.services_list.get_iter(path)
        name, enabled, writable = self.services_list[iter]

        if not writable:
            return

        new_val = not enabled
        self.services_list[iter][1] = new_val
        set_service_enabled(name, new_val)

    def on_search(self, entry):
        text = entry.get_text().lower()

        self.autostart_list.clear()
        for row in toast_filter_list(self._autostart_original, text, [0]):
            self.autostart_list.append(row)

        self.services_list.clear()
        for row in toast_filter_list(self._services_original, text, [0]):
            self.services_list.append(row)

# ===========================
# ENTRY POINT
# ===========================

def main():
    win = ToastWindow()
    win.connect("destroy", Gtk.main_quit)
    win.show_all()
    Gtk.main()


if __name__ == "__main__":
    main()
